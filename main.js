const fs = require("node:fs"), path = require("node:path"), proc = require("node:child_process"), root = path.dirname(process.argv[1]), env = {};

projects = undefined;
project_tool = undefined;
config = undefined;
toolchain = undefined;
function init() {
    projects = path.join(root, "projects");
    if (!fs.existsSync(projects)) {
        console.log(`Creating projects directory at: "${projects}"`);
        fs.mkdirSync(projects);
    }

    config = require("./config.json");
    for(let key in config) {
        if (key.endsWith("@path")) {
            let val = config[key];
            while (val.includes("%")) {
                const ind = val.indexOf("%");
                const end = val.indexOf("%", ind + 1);
                if (end === -1) throw `Could not find end of variable in config value: "${val}" for ${key}`;

                const varname = val.slice(ind + 1, end), get = env[varname] ?? process.env[varname] ?? config[varname];
                if (get === undefined) throw `Could not find value of variable "${varname}" in config value: "${val}" for ${key}`;
                val = val.slice(0, ind) + get + val.slice(end + 1);
            }
            config[key] = path.normalize(val);
            if (!fs.existsSync(config[key])) throw `Could not read non-existent path: "${config[key]}" for ${key}`;
        }
    }
    project_tool = config["project@path"];

    toolchain = path.join(config["toolchain@path"], config["toolchain@type"]);
    if (!fs.existsSync(toolchain)) throw `Could not resolve toolchain path at: "${toolchain}", ensure Cronus packages are installed and retry`;
    return true;
}

function create(name, format="JUN23") {
    const project = (name ?? "").toLowerCase().trim();
    if (project.length == 0) throw `Could not create project with invalid name: "${name}" (${name.length} character${name.length === 1 ? "" : "s"})`;

    const location = path.join(projects, project + "\\");
    if (fs.existsSync(location)) throw `Could not create project with name: "${name}", project already exists at: "${location}"`;
    else fs.mkdirSync(location);

    const script = path.join(location, "script.txt");
    fs.writeFileSync(script, `# Generated by Hera\nCLI\nPROJECT NEW Name="${name}" Path="${location}"\nPROJECT SAVE Format=${format}\nEXIT`);

    const exec = proc.execFileSync(project_tool, ["SCRIPT", "Path=" + script]).toString().trim();
    if (!exec.endsWith("Successful")) throw `Could not create project, ${path.basename(project_tool)} failed with the following output:\n${exec}`;
    fs.rmSync(script);

    console.log(`Successfully created new project: ${name} (${format}) at "${location}"`);
    return true;
}

function remove(name) {
    const project = (name ?? "").toLowerCase().trim();
    if (project.length == 0) throw `Could not remove project with invalid name: "${name}" (${name.length} character${name.length === 1 ? "" : "s"})`;

    const location = path.join(projects, project);
    if (!fs.existsSync(location)) throw `Could not remove project with name: "${name}", project does not exist at: "${location}"`;
    
    fs.rmdirSync(location, {recursive: true});
    console.log(`Successfully removed project: ${name}`);
    return true;
}

const version = "1.0.0", inject = ["-create", "test"];
try {
    const time = Date.now(), commands = {
        "create": {
            description: "Create a new project in Hera's workspace",
            arguments: [
                {name: "name", description: "The name of the project to create"}
            ],
            callback: create
        },
        "remove": {
            description: "Removes the project from Hera's workspace",
            arguments: [
                {name: "name", description: "The name of the project to delete"}
            ],
            callback: remove
        },
        "help": {
            description: "Prints out a list of Hera's available commands",
            callback: function() {
                console.log(`Hera v${version} by Nommiin\n${"=".repeat(16)}`);
                for(const command in commands) {
                    const cmd = commands[command];
                    if (cmd === this) continue;

                    let args = cmd.arguments, out = "-" + command;
                    if (args !== undefined) {
                        out += " " + args.map(e => `${e.name}`).join(" ");
                    }
                    out += `\n${cmd.description}`;
                    console.log(out);
                }
                console.log("=".repeat(16));
                return true;
            }
        }
    };

    if (!(function(args) {
        if (args.length == 0) throw `Please provide at least 1 argument, use "-help" for available commands`;
        if (!init()) throw `Failed to initialize Hera`;

        const first = args[0].toLowerCase();
        for(const command in commands) {
            const cmd = commands[command];
            if ("-" + command === first) {
                context = command;

                const req = cmd.arguments;
                if (req !== undefined) {
                    if (args.length - 1 < req.length) {
                        throw `Invalid amount of arguments provided (got ${args.length} but expected ${req.length + 1}), use "-help" for more information`;
                    }
                }
                return cmd.callback(...args.slice(1));;
            }
        }
        throw `Could not evaluate invalid argument: ${first}`;
    })(inject ?? process.argv.slice(2))) {
        process.exit(1);
    }
    console.log(`Hera execution finished in ${Date.now() - time}ms`);
} catch (e) {
    console.log(`Hera execution failed with exception:\n- ${e}`);
}
process.exit(0);